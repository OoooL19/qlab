target_rt <- NULL
preceding_rt <- NULL
id <- NULL
trial <-NULL
this_id <- NULL
this_trial_num <- NULL
this_loop <- NULL
loop <- NULL
preceding_loop <- NULL
loop_before <- NULL
this_targ_rt <- NULL
rt_before <- NULL
case <- NULL
this_trial_before <- NULL
this_trial_num_before <- NULL
trial_before_df <- NULL
trial_num_before <- NULL
# Isolate participants' response times.
# Include rows when the participant responded to the stimulus preceding the target (i.e. any time that the participant pressed the button within one stimulus before the target)
for(i in 1:nrow(structured_lv_targets))
{
# Isolate the ID number
this_id <- structured_lv_targets[i,]$part_id
id <- append(id, paste(this_id))
# Isolate the trial number
this_trial_num <- structured_lv_targets[i,]$trialnum
trial <- append(trial, paste(this_trial_num))
# Isolate the target's rt
this_targ_rt <- structured_lv_targets[i,]$l_block_trial_key_resp.rt
target_rt <- append(target_rt, paste(this_targ_rt))
# Isolate the loop value
this_loop <- structured_lv_targets[i,]$l_block_trial_loop.thistrialn
loop <- append (loop, this_loop)
# Isolate the row with the preceding trial for that participant
this_trial_before <- structured_lv[which(structured_lv$trialnum==this_trial_num-1 & structured_lv$part_id==this_id), ][1,]
trial_before_df <- rbind (this_trial_before, this_trial_before)
this_trial_num_before <- this_trial_before$trialnum
trial_num_before <- append (trial_num_before, this_trial_num)
# Isolate the preceding row's this_l_loop value.
preceding_loop <- this_trial_before$l_block_trial_loop.thistrialn
loop_before <- append(loop_before, preceding_loop)
#loop_after <- append (loop_after, folvowing_loop)
preceding_rt <- this_trial_before$l_block_trial_key_resp.rt
rt_before <- append (rt_before, preceding_rt)
# If the participant responded while the target was presented
if (!is.na(structured_lv_targets[i,] [,"l_block_trial_key_resp.rt"])){
# Count their response time from the target stimulus
rt_col <- append (rt_col, structured_lv_targets[i,][,"l_block_trial_key_resp.rt"])
}
# If the participant responded during the stimulus preceding the target (implies that we are not in the first row, which would not have a preceding row)
else if (!is.na(this_trial_before["l_block_trial_key_resp.rt"])){
# And the preceding line is from the same block
if (preceding_loop==this_loop-1){
# Take the rt from the preceding line and subtract it from 0, to determine how far in advance they responded
rt_col <- append (rt_col, 0-(1000-preceding_rt))
case <- append (case, "case 2")}
else {
# Copy the target response time of NA
rt_col <- append (rt_col, this_targ_rt)
case <- append (case, "case 3")}
}
# If the participant did not respond within 1 stimulus preceding the target,
else if (is.na(structured_lv_targets[i,] [,"l_block_trial_key_resp.rt"])){
# Copy their response time of NA
rt_col <- append (rt_col, this_targ_rt)
case <- append (case, "case 4")}
else{
rt_col <- append (rt_col, "anomaly, this shouldn't happen")
case <- append (case, "case 5")}
}
# Match id and response times
structured_lv_extracted <- data.frame(id, trial, trial_num_before, loop, loop_before, target_rt, rt_before, rt_col)
# Reindex the trial numbers for only trials with response times -----------------------------------------------------------------------------------------------------
# List unique participant IDs for this condition
extracted_part_id <- unique(structured_lv_extracted$id)
# Find the number of targets shown to each participant
target_sum <- NULL
for(i in extracted_part_id){target_sum <- append(target_sum,sum(structured_lv_extracted$id==i))}
# TEST: This should be equal to 26
length (target_sum)
# TEST: This should contain a vector full of 24s
target_sum
# For each participant, index the targets
targ_index <- NULL
for (i in target_sum) {targ_index <- append (targ_index, rep(1:i, 1))}
# Add the targets' indices
structured_lv_extracted$targ_index <- targ_index
# Remove any values of NA
structured_lv_extracted <- structured_lv_extracted[!is.na(structured_lv_extracted$rt_col),]
# Calculate mean rt and rt_slope  -----------------------------------------------------------------------------------------------------
# Define variables
mean_rt <- NULL
rt_slope <- NULL
part_id <- NULL
type <- NULL
task<- NULL
same_or_diff <- NULL
test_phase <- NULL
slv<- NULL
domain <- NULL
range <- NULL
upper_bound <- NULL
lower_bound <- NULL
this_range <- NULL
# For each participant, extract id
# Assign domain and type
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in extracted_part_id){
part_id <- append(part_id, id)
domain <- append(domain, "linguistic")
task <- append(task, "lv")
type <- append (type, "structured")
same_or_diff <- append (same_or_diff, "different")
test_phase <- append (test_phase, "lsl")
mean_rt <- append(mean_rt, round(mean(structured_lv_extracted$rt_col[structured_lv_extracted$id==id]),digits=3))
rt_slope <- append (rt_slope, round(summary(lm(structured_lv_extracted$rt_col[structured_lv_extracted$id==id]~structured_lv_extracted$targ_index[structured_lv_extracted$id==id]))$coefficient[2,1],digits = 4))
data_this_id <- (structured_lv_extracted[ which(structured_lv_extracted$id==id),])
this_range<- range(data_this_id$rt_col, na.rm = TRUE)
range <- append (range, this_range)
upper_bound <- append (upper_bound,this_range[1])
lower_bound <- append (lower_bound,this_range[2])
}
# Combine data for each participant
slv <- data.frame(part_id, task, same_or_diff, test_phase, domain,type,mean_rt, range, upper_bound, lower_bound, rt_slope)
# TEST: find mean rt_slope
mean_slv_rt_slope <- mean (slv$rt_slope)
# It should be negative
mean_slv_rt_slope
# ******************** CONDITION 7: vl structured*******************
# Separate structured and structured conditions
structured_vl <- vl_data_frame[ which(vl_data_frame$condition== "S"),]
# Identify the rows when this condition's target was presented
structured_vl_targets <- structured_vl[which(structured_vl$structured_targ==structured_vl$image),]
## Index the images by structured/ structured-----------------------------------------------
# TEST: Create a data frame to check the number of lines per participant
list_part_id <- unique(structured_vl_targets$part_id)
part_id <- NULL
total_lines <- NULL
for(id in list_part_id){
part_id <- append(part_id, id)
total_lines <- append(total_lines, nrow(structured_vl_targets[which(structured_vl$part_id==id),]))
}
svl_line_number <- data.frame(part_id, total_lines)
# There should be 26 entries
length(svl_line_number$part_id)
# They should all contain 288 lines
svl_line_number$total_lines
# Identify response times to target stimuli. Include times when participant responded while target was displayed, or during preceding/ fovlowing stimulus ---------------------------------------------
# Set up variables to loop through participants by trials and track the target
rt_col <- NULL
target_rt <- NULL
preceding_rt <- NULL
id <- NULL
trial <-NULL
this_id <- NULL
this_trial_num <- NULL
this_loop <- NULL
loop <- NULL
preceding_loop <- NULL
loop_before <- NULL
this_targ_rt <- NULL
rt_before <- NULL
case <- NULL
this_trial_before <- NULL
this_trial_num_before <- NULL
trial_before_df <- NULL
trial_num_before <- NULL
# Identify the rows when this condition's target was presented
structured_vl_targets <- structured_vl[which(structured_vl$structured_targ==structured_vl$image),]
# Isolate participants' response times.
# Include rows when the participant responded to the stimulus preceding the target (i.e. any time that the participant pressed the button within one stimulus before the target)
for(i in 1:nrow(structured_vl_targets))
{
# Isolate the ID number
this_id <- structured_vl_targets[i,]$part_id
id <- append(id, paste(this_id))
# Isolate the trial number
this_trial_num <- structured_vl_targets[i,]$trial_num
trial <- append(trial, paste(this_trial_num))
# Isolate the target's rt
this_targ_rt <- structured_vl_targets[i,]$v_block_trial_key_resp.rt
target_rt <- append(target_rt, paste(this_targ_rt))
# Isolate the loop value
this_loop <- structured_vl_targets[i,]$v_block_trials.thistrialn
loop <- append (loop, this_loop)
# Isolate the row with the preceding trial for that participant
this_trial_before <- structured_vl[which(structured_vl$trial_num==this_trial_num-1 & structured_vl$part_id==this_id), ][1,]
trial_before_df <- rbind (this_trial_before, this_trial_before)
this_trial_num_before <- this_trial_before$trial_num
trial_num_before <- append (trial_num_before, this_trial_num)
# Isolate the preceding row's this_v_loop value.
preceding_loop <- this_trial_before$v_block_trials.thistrialn
loop_before <- append(loop_before, preceding_loop)
#loop_after <- append (loop_after, fovlowing_loop)
preceding_rt <- this_trial_before$v_block_trial_key_resp.rt
rt_before <- append (rt_before, preceding_rt)
# If the participant responded while the target was presented
if (!is.na(structured_vl_targets[i,] [,"v_block_trial_key_resp.rt"])){
# Count their response time from the target stimulus
rt_col <- append (rt_col, structured_vl_targets[i,][,"v_block_trial_key_resp.rt"])
}
# If the participant responded during the stimulus preceding the target (implies that we are not in the first row, which would not have a preceding row)
else if (!is.na(this_trial_before["v_block_trial_key_resp.rt"])){
# And the preceding line is from the same block
if (preceding_loop==this_loop-1){
# Take the rt from the preceding line and subtract it from 0, to determine how far in advance they responded
rt_col <- append (rt_col, 0-(1000-preceding_rt))
case <- append (case, "case 2")}
else {
# Copy the target response time of NA
rt_col <- append (rt_col, this_targ_rt)
case <- append (case, "case 3")}
}
# If the participant did not respond within 1 stimulus preceding the target,
else if (is.na(structured_vl_targets[i,] [,"v_block_trial_key_resp.rt"])){
# Copy their response time of NA
rt_col <- append (rt_col, this_targ_rt)
case <- append (case, "case 4")}
else{
rt_col <- append (rt_col, "anomaly, this shouldn't happen")
case <- append (case, "case 5")}
}
# Match id and response times
structured_vl_extracted <- data.frame(id, trial, trial_num_before, loop, loop_before, target_rt, rt_before, rt_col)
# Reindex the trial numbers for only trials with response times -----------------------------------------------------------------------------------------------------
# List unique participant IDs for this condition
extracted_part_id <- unique(structured_vl_extracted$id)
# Find the number of targets shown to each participant
target_sum <- NULL
for(i in extracted_part_id){target_sum <- append(target_sum,sum(structured_vl_extracted$id==i))}
# TEST: This should be equal to 26
length (target_sum)
# TEST: This should contain a vector full of 24s
# ATTN AN: Do you know why we only see 20?
target_sum
# TEST: This should contain a vector full of 24s
target_sum
# For each participant, index the targets
targ_index <- NULL
for (i in target_sum) {targ_index <- append (targ_index, rep(1:i, 1))}
# Add the targets' indices
structured_vl_extracted$targ_index <- targ_index
# Remove any values of NA
structured_vl_extracted <- structured_vl_extracted[!is.na(structured_vl_extracted$rt_col),]
# Define variables
mean_rt <- NULL
rt_slope <- NULL
part_id <- NULL
type <- NULL
task<- NULL
same_or_diff <- NULL
test_phase <- NULL
svl<- NULL
domain <- NULL
range <- NULL
upper_bound <- NULL
lower_bound <- NULL
this_range <- NULL
# For each participant, extract id
# Assign domain and type
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in extracted_part_id){
part_id <- append(part_id, id)
domain <- append(domain, "linguistic")
task <- append(task, "vl")
type <- append (type, "structured")
same_or_diff <- append (same_or_diff, "different")
test_phase <- append (test_phase, "vsl")
mean_rt <- append(mean_rt, round(mean(structured_vl_extracted$rt_col[structured_vl_extracted$id==id]),digits=3))
rt_slope <- append (rt_slope, round(summary(lm(structured_vl_extracted$rt_col[structured_vl_extracted$id==id]~structured_vl_extracted$targ_index[structured_vl_extracted$id==id]))$coefficient[2,1],digits = 4))
data_this_id <- (structured_vl_extracted[ which(structured_vl_extracted$id==id),])
this_range<- range(data_this_id$rt_col, na.rm = TRUE)
range <- append (range, this_range)
upper_bound <- append (upper_bound,this_range[1])
lower_bound <- append (lower_bound,this_range[2])
}
# Combine data for each participant
svl <- data.frame(part_id, task, same_or_diff, test_phase, domain,type,mean_rt, range, upper_bound, lower_bound, rt_slope)
# for internal checking only: find mean rt_slope
mean_svl_rt_slope <- mean (slv$rt_slope)
# TEST: find mean rt_slope
mean_svl_rt_slope <- mean (svl$rt_slope)
# It should be negative
mean_svl_rt_slope
# Separate structured and structured conditions
structured_vv <- vv_data_frame[ which(vv_data_frame$condition== "S"),]
# Identify the rows when this condition's target was presented
structured_vv_targets <- structured_vv[which(structured_vv$first_targ==structured_vv$image),]
# TEST: Create a data frame to check the number of lines per participant
list_part_id <- unique(structured_vv_targets$part_id)
# Remove objects in environment
rm(list=ls())
#For use on Mac
ll_input <- ("../../../sit_data/clean/ll_clean/")
lv_input <- ("../../../sit_data/clean/lv_clean/")
vl_input <- ("../../../sit_data/clean/vl_clean/")
vv_input <- ("../../../sit_data/clean/vv_clean/")
vocab_input <- ("../../../sit_data/clean/vocab_clean/vocab_clean.csv")
#Read in picture vocabulary scores
picture_vocab <- read.csv(vocab_input)
ll_underscore_files <- list.files(path=ll_input, pattern = ".csv")
#Remove the underscores in file names
ll_files <- gsub("_", "", ll_underscore_files)
# Prepare data_frame to hold the files you're reading in
ll_data_frame<-list()
# Remove the dashes in each file name read it in
for(file in ll_underscore_files)
{
assign(
gsub("_", "", file),
read_file <- read.csv(paste(ll_input, file, sep="")))
}
# Combine each file with the previous files into ll_data_frame
for (file in ll_files){ll_data_frame <- append(ll_data_frame, list(eval(parse(text=file))))}
ll_data_frame <- do.call(rbind.data.frame, ll_data_frame)
lv_underscore_files <- list.files(path=lv_input, pattern = ".csv")
#Remove the underscores in file names
lv_files <- gsub("_", "", lv_underscore_files)
# Prepare data_frame to hold the files you're reading in
lv_data_frame<-list()
# Remove the dashes in each file name read it in
for(file in lv_underscore_files)
{
assign(
gsub("_", "", file),
read_file <- read.csv(paste(lv_input, file, sep="")))
}
# Combine each file with the previous files into lv_data_frame
for (file in lv_files){lv_data_frame <- append(lv_data_frame, list(eval(parse(text=file))))}
lv_data_frame <- do.call(rbind.data.frame, lv_data_frame)
vl_underscore_files <- list.files(path=vl_input, pattern = ".csv")
#Remove the underscores in file names
vl_files <- gsub("_", "", vl_underscore_files)
# Prepare data_frame to hold the files you're reading in
vl_data_frame<-list()
# Remove the dashes in each file name read it in
for(file in vl_underscore_files)
{
assign(
gsub("_", "", file),
read_file <- read.csv(paste(vl_input, file, sep="")))
}
# Combine each file with the previous files into vl_data_frame
for (file in vl_files){vl_data_frame <- append(vl_data_frame, list(eval(parse(text=file))))}
vl_data_frame <- do.call(rbind.data.frame, vl_data_frame)
vv_underscore_files <- list.files(path=vv_input, pattern = ".csv")
#Remove the underscores in file names
vv_files <- gsub("_", "", vv_underscore_files)
# Prepare data_frame to hold the files you're reading in
vv_data_frame<-list()
# Remove the dashes in each file name read it in
for(file in vv_underscore_files)
{
assign(
gsub("_", "", file),
read_file <- read.csv(paste(vv_input, file, sep="")))
}
# Combine each file with the previous files into vv_data_frame
for (file in vv_files){vv_data_frame <- append(vv_data_frame, list(eval(parse(text=file))))}
vv_data_frame <- do.call(rbind.data.frame, vv_data_frame)
# List unique participant IDs for this condition
list_part_id <- unique(lv_data_frame$part_id)
# Set up data frame to hold accuracies
accuracy <- NULL
part_id <- NULL
task <- NULL
same_or_diff <-NULL
test_phase <- NULL
# For each participant, extract id
# Assign domain, same_or_diff, and modality
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in list_part_id){
part_id <- append(part_id, id)
task <- append(task, "lv")
same_or_diff <- append(same_or_diff, "different")
test_phase <- append (test_phase, "lsl")
accuracy <- append(accuracy, round(mean(lv_data_frame[which(lv_data_frame$part_id==id),]$corr_resp, na.rm=TRUE), digits = 3))
}
# Combine data for each participant
indiv_lv_accuracies <- data.frame(part_id, task, same_or_diff, test_phase, accuracy)
# TEST: There should be 26 entries
length(indiv_lv_accuracies$part_id)
# TEST: All entries should all have an accuracy value
View(indiv_lv_accuracies)
# List unique participant IDs for this condition
list_part_id <- unique(ll_data_frame$part_id)
# Set up data frame to hold accuracies
accuracy <- NULL
part_id <- NULL
task <- NULL
same_or_diff <-NULL
test_phase <- NULL
# For each participant, extract id
# Assign domain, same_or_diff, and modality
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in list_part_id){
part_id <- append(part_id, id)
task <- append(task, "ll")
same_or_diff <- append(same_or_diff, "same")
test_phase <- append (test_phase, "lsl")
accuracy <- append(accuracy, round(mean(ll_data_frame[which(ll_data_frame$part_id==id),]$corr_resp, na.rm=TRUE), digits = 3))
}
# Combine data for each participant
indiv_ll_accuracies <- data.frame(part_id, task, same_or_diff, test_phase, accuracy)
# TEST: There should be 22 entries
length(indiv_ll_accuracies$part_id)
# TEST: All entries should all have an accuracy value
View(indiv_ll_accuracies)
# List unique participant IDs for this condition
list_part_id <- unique(vl_data_frame$part_id)
# Set up data frame to hold accuracies
accuracy <- NULL
part_id <- NULL
task<- NULL
same_or_diff <-NULL
test_phase <- NULL
# For each participant, extract id
# Assign domain, same_or_diff, and modality
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in list_part_id){
part_id <- append(part_id, id)
task <- append(task, "vl")
same_or_diff <- append(same_or_diff, "different")
test_phase <- append (test_phase, "vsl")
accuracy <- append(accuracy, round(mean(vl_data_frame[which(vl_data_frame$part_id==id),]$corr_resp, na.rm=TRUE), digits = 3))
}
# Combine data for each participant
indiv_vl_accuracies <- data.frame(part_id, task, same_or_diff, test_phase, accuracy)
# TEST: There should be 26 entries
length(indiv_vl_accuracies$part_id)
# TEST: All entries should all have an accuracy value
View(indiv_vl_accuracies)
# List unique participant IDs for this condition
list_part_id <- unique(vv_data_frame$part_id)
# Set up data frame to hold accuracies
accuracy <- NULL
part_id <- NULL
task<- NULL
same_or_diff <- NULL
test_phase <- NULL
# For each participant, extract id
# Assign domain, same_or_diff, and modality
# Calculate and record mean_rt, rt_slope, upper bound, and lower bound
for(id in list_part_id){
part_id <- append(part_id, id)
task <- append(task, "vv")
same_or_diff <- append(same_or_diff, "same")
test_phase <- append(test_phase, "vsl")
#accuracy <- append(accuracy, round(mean(vv_data_frame[ which(vv_data_frame$PartID==id), ]$corr_resp, na.rm=TRUE), digits =3),)
accuracy <- append(accuracy, round(mean(vv_data_frame[which(vv_data_frame$part_id==id),]$corr_resp, na.rm=TRUE), digits = 3))
}
# Combine data for each participant
indiv_vv_accuracies <- data.frame(part_id, task, same_or_diff, test_phase, accuracy)
# TEST: There should be 22 entries
length(indiv_vv_accuracies$part_id)
# TEST: All entries should all have an accuracy value
View(indiv_vv_accuracies)
#Summarize individual accuracies--------
indiv_accuracies <- rbind(indiv_ll_accuracies, indiv_lv_accuracies, indiv_vl_accuracies, indiv_vv_accuracies)
indiv_accuracies_wide <- cast(indiv_accuracies, part_id ~ task, mean, value = 'accuracy')
indiv_accuracies_wide<- merge(indiv_accuracies_wide, picture_vocab, by = "part_id", all=TRUE)
indiv_accuracies_wide <- cbind(indiv_accuracies_wide, "same_or_diff")
colnames(indiv_accuracies_wide)[9] <- "same_or_diff"
all_same <- indiv_accuracies_wide[ which(indiv_accuracies_wide$ll>0), ]
all_same$same_or_diff <- ("same")
all_diff <- indiv_accuracies_wide[ which(indiv_accuracies_wide$lv>0), ]
all_diff$same_or_diff <- ("different")
indiv_accuracies_wide <- rbind(all_same, all_diff)
#Write individual accuracies to output file
write.csv(indiv_accuracies_wide, "sit_accuracy_indiv.csv")
corr_data <- cast(indiv_accuracies, part_id ~ task, mean, value = 'accuracy')
corr_data <- cast(indiv_accuracies, part_id ~ task, mean, value = 'accuracy')
corr_data <- merge(corr_data, picture_vocab, by = "part_id", all=TRUE)
same_corr <- corr_data[ which(!is.na(corr_data$ll)), ]
same_corr <- same_corr[, c(2, 5, 6)]
diff_corr <- corr_data[ which(!is.na(corr_data$lv)), ]
diff_corr <- diff_corr[, c(3, 4, 6)]
same_corr$vv<-as.numeric(same_corr$vv)
diff <- cor(diff_corr, method = c("pearson"),use="pairwise.complete.obs")
same <- cor(same_corr, method = c("pearson"),use="pairwise.complete.obs")
View(corr_data)
corr_data <- cast(indiv_accuracies, part_id ~ task, mean, value = 'accuracy')
corr_data <- merge(corr_data, picture_vocab, by = "part_id", all=TRUE)
chi_square_table <- cbind(corr_data, "same_or_diff")
View(chi_square_table)
chi_square_data <- cbind(corr_data, "same_or_diff")
View(chi_square_data)
colnames(indiv_rt_slope_wide)[9] <- "same_or_diff"
colnames(chi_square_data)[9] <- "same_or_diff"
chi_square_data <- cbind(corr_data, "same_or_diff")
colnames(chi_square_data)[9] <- "same_or_diff"
all_same <- chi_square_data[ which(chi_square_data$ll>0), ]
all_same$same_or_diff <- ("same")
all_diff <- chi_square_data[ which(chi_square_data$lv>0), ]
all_diff$same_or_diff <- ("different")
chi_square_data <- rbind(all_same, all_diff)
View(chi_square_data)
chi_square_data <- chi_square_data[ which(chi_square_data$score>0), ]
chi_age <- c((mean(chi_square_data[which(chi_square_data$same_or_diff=="same")])$age))
mean_same_age <- chi_square_data[ which(chi_square_data$same_or_diff=="same"), ]
mean_same_age <- mean(chi_square_data[ which(chi_square_data$same_or_diff=="same"), ]$age)
mean_same_age
mean_same_age <- c(mean(chi_square_data[ which(chi_square_data$same_or_diff=="same"), ]$age),
mean(chi_square_data[ which(chi_square_data$same_or_diff=="different"), ]$age))
mean_same_age
mean_score <- c(mean(chi_square_data[ which(chi_square_data$same_or_diff=="same"), ]$score),
mean(chi_square_data[ which(chi_square_data$same_or_diff=="different"), ]$score))
mean_score
table(chi_square_data)
[1]
}
)
